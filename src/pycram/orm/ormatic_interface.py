# Generated by ORMatic

from __future__ import annotations
from sqlalchemy import (
    Column,
    ForeignKey,
    Integer,
    String,
    Float,
    Boolean,
    DateTime,
    Enum,
    JSON,
)
from sqlalchemy.orm import relationship, Mapped, mapped_column, DeclarativeBase

import builtins
import datetime
import krrood.ormatic.custom_types
import numpy
import pycram.datastructures.dataclasses
import pycram.datastructures.enums
import pycram.datastructures.grasp
import pycram.datastructures.pose
import pycram.language
import pycram.orm.model
import pycram.robot_plans.actions.base
import pycram.robot_plans.actions.composite.facing
import pycram.robot_plans.actions.composite.searching
import pycram.robot_plans.actions.composite.tool_based
import pycram.robot_plans.actions.composite.transporting
import pycram.robot_plans.actions.core.container
import pycram.robot_plans.actions.core.misc
import pycram.robot_plans.actions.core.navigation
import pycram.robot_plans.actions.core.pick_up
import pycram.robot_plans.actions.core.placing
import pycram.robot_plans.actions.core.robot_body
import semantic_digital_twin.adapters.procthor.procthor_semantic_annotations
import semantic_digital_twin.datastructures.prefixed_name
import semantic_digital_twin.orm.model
import semantic_digital_twin.reasoning.predicates
import semantic_digital_twin.robots.abstract_robot
import semantic_digital_twin.semantic_annotations.mixins
import semantic_digital_twin.semantic_annotations.semantic_annotations
import semantic_digital_twin.world
import semantic_digital_twin.world_description.connections
import semantic_digital_twin.world_description.geometry
import semantic_digital_twin.world_description.shape_collection
import semantic_digital_twin.world_description.world_entity
import semantic_digital_twin.world_description.world_modification
import trimesh.base
import typing
import typing_extensions


from krrood.ormatic.dao import DataAccessObject
from krrood.ormatic.custom_types import TypeType


class Base(DeclarativeBase):
    type_mappings = {
        trimesh.base.Trimesh: semantic_digital_twin.orm.model.TrimeshType,
        typing.Type: krrood.ormatic.custom_types.TypeType,
        numpy.ndarray: pycram.orm.model.NumpyType,
    }


class ActionDescriptionDAO(
    Base, DataAccessObject[pycram.robot_plans.actions.base.ActionDescription]
):

    __tablename__ = "ActionDescriptionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    execution_data_id: Mapped[int] = mapped_column(
        ForeignKey("ExecutionDataDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    execution_data: Mapped[ExecutionDataDAO] = relationship(
        "ExecutionDataDAO",
        uselist=False,
        foreign_keys=[execution_data_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "ActionDescriptionDAO",
    }


class BoundingBoxDAO(
    Base, DataAccessObject[semantic_digital_twin.world_description.geometry.BoundingBox]
):

    __tablename__ = "BoundingBoxDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    min_x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    min_y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    min_z: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    max_x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    max_y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    max_z: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    origin_id: Mapped[int] = mapped_column(
        ForeignKey("TransformationMatrixMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    origin: Mapped[TransformationMatrixMappingDAO] = relationship(
        "TransformationMatrixMappingDAO",
        uselist=False,
        foreign_keys=[origin_id],
        post_update=True,
    )


class CarryActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.robot_body.CarryAction],
):

    __tablename__ = "CarryActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    align: Mapped[typing.Optional[builtins.bool]] = mapped_column(
        use_existing_column=True
    )
    tip_link: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )
    tip_axis: Mapped[typing.Optional[pycram.datastructures.enums.AxisIdentifier]] = (
        mapped_column(use_existing_column=True)
    )
    root_link: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )
    root_axis: Mapped[typing.Optional[pycram.datastructures.enums.AxisIdentifier]] = (
        mapped_column(use_existing_column=True)
    )

    __mapper_args__ = {
        "polymorphic_identity": "CarryActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class CloseActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.container.CloseAction],
):

    __tablename__ = "CloseActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    grasping_prepose_distance: Mapped[builtins.float] = mapped_column(
        use_existing_column=True
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CloseActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class CollisionCheckingConfigDAO(
    Base,
    DataAccessObject[
        semantic_digital_twin.world_description.world_entity.CollisionCheckingConfig
    ],
):

    __tablename__ = "CollisionCheckingConfigDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    buffer_zone_distance: Mapped[typing.Optional[builtins.float]] = mapped_column(
        use_existing_column=True
    )
    violated_distance: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    disabled: Mapped[typing.Optional[builtins.bool]] = mapped_column(
        use_existing_column=True
    )
    max_avoided_bodies: Mapped[builtins.int] = mapped_column(use_existing_column=True)


class CollisionPairManagerDAO(
    Base, DataAccessObject[semantic_digital_twin.world.CollisionPairManager]
):

    __tablename__ = "CollisionPairManagerDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    world_id: Mapped[int] = mapped_column(
        ForeignKey("WorldMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    world: Mapped[WorldMappingDAO] = relationship(
        "WorldMappingDAO", uselist=False, foreign_keys=[world_id], post_update=True
    )


class ColorDAO(
    Base, DataAccessObject[semantic_digital_twin.world_description.geometry.Color]
):

    __tablename__ = "ColorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    R: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    G: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    B: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    A: Mapped[builtins.float] = mapped_column(use_existing_column=True)


class ContainsTypeDAO(
    Base, DataAccessObject[semantic_digital_twin.reasoning.predicates.ContainsType]
):

    __tablename__ = "ContainsTypeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )


class CuttingActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.composite.tool_based.CuttingAction],
):

    __tablename__ = "CuttingActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    technique: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )
    slice_thickness: Mapped[typing.Optional[builtins.float]] = mapped_column(
        use_existing_column=True
    )

    object__id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    tool_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object__id], post_update=True
    )
    tool: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[tool_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CuttingActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class DetectActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.misc.DetectAction],
):

    __tablename__ = "DetectActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    technique: Mapped[pycram.datastructures.enums.DetectionTechnique] = mapped_column(
        use_existing_column=True
    )
    state: Mapped[typing.Optional[pycram.datastructures.enums.DetectionState]] = (
        mapped_column(use_existing_column=True)
    )

    object_designator_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    region_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    region: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[region_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "DetectActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class EfficientTransportActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[
        pycram.robot_plans.actions.composite.transporting.EfficientTransportAction
    ],
):

    __tablename__ = "EfficientTransportActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    target_location_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    target_location: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[target_location_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "EfficientTransportActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class ExecutionDataDAO(
    Base, DataAccessObject[pycram.datastructures.dataclasses.ExecutionData]
):

    __tablename__ = "ExecutionDataDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    manipulated_body_name: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )

    execution_start_world_state: Mapped[pycram.orm.model.NumpyType] = mapped_column(
        pycram.orm.model.NumpyType, nullable=False, use_existing_column=True
    )
    execution_end_world_state: Mapped[typing.Optional[pycram.orm.model.NumpyType]] = (
        mapped_column(
            pycram.orm.model.NumpyType, nullable=True, use_existing_column=True
        )
    )

    execution_start_pose_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    execution_end_pose_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    manipulated_body_pose_start_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("PoseStampedDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )
    manipulated_body_pose_end_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    manipulated_body_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    execution_start_pose: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[execution_start_pose_id],
        post_update=True,
    )
    execution_end_pose: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[execution_end_pose_id],
        post_update=True,
    )
    added_world_modifications: Mapped[typing.List[WorldModelModificationBlockDAO]] = (
        relationship(
            "WorldModelModificationBlockDAO",
            foreign_keys="[WorldModelModificationBlockDAO.executiondatadao_added_world_modifications_id]",
            post_update=True,
        )
    )
    manipulated_body_pose_start: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[manipulated_body_pose_start_id],
        post_update=True,
    )
    manipulated_body_pose_end: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[manipulated_body_pose_end_id],
        post_update=True,
    )
    manipulated_body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[manipulated_body_id], post_update=True
    )


class FaceAtActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.composite.facing.FaceAtAction],
):

    __tablename__ = "FaceAtActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    keep_joint_states: Mapped[builtins.bool] = mapped_column(use_existing_column=True)

    pose_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    pose: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO", uselist=False, foreign_keys=[pose_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "FaceAtActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class FieldOfViewDAO(
    Base, DataAccessObject[semantic_digital_twin.robots.abstract_robot.FieldOfView]
):

    __tablename__ = "FieldOfViewDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    vertical_angle: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    horizontal_angle: Mapped[builtins.float] = mapped_column(use_existing_column=True)


class GraspDescriptionDAO(
    Base, DataAccessObject[pycram.datastructures.grasp.GraspDescription]
):

    __tablename__ = "GraspDescriptionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    approach_direction: Mapped[pycram.datastructures.enums.ApproachDirection] = (
        mapped_column(use_existing_column=True)
    )
    vertical_alignment: Mapped[pycram.datastructures.enums.VerticalAlignment] = (
        mapped_column(use_existing_column=True)
    )
    rotate_gripper: Mapped[builtins.bool] = mapped_column(use_existing_column=True)


class GraspingActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.pick_up.GraspingAction],
):

    __tablename__ = "GraspingActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    prepose_distance: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "GraspingActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class HeaderDAO(Base, DataAccessObject[pycram.datastructures.pose.Header]):

    __tablename__ = "HeaderDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    stamp: Mapped[datetime.datetime] = mapped_column(use_existing_column=True)
    sequence: Mapped[builtins.int] = mapped_column(use_existing_column=True)

    frame_id_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    frame_id: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[frame_id_id], post_update=True
    )


class LookAtActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.navigation.LookAtAction],
):

    __tablename__ = "LookAtActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    target_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    target: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO", uselist=False, foreign_keys=[target_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "LookAtActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class MixingActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.composite.tool_based.MixingAction],
):

    __tablename__ = "MixingActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    technique: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )

    object__id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    tool_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object__id], post_update=True
    )
    tool: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[tool_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "MixingActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class MoveAndPickUpActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[
        pycram.robot_plans.actions.composite.transporting.MoveAndPickUpAction
    ],
):

    __tablename__ = "MoveAndPickUpActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    keep_joint_states: Mapped[builtins.bool] = mapped_column(use_existing_column=True)

    standing_position_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    grasp_description_id: Mapped[int] = mapped_column(
        ForeignKey("GraspDescriptionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    standing_position: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[standing_position_id],
        post_update=True,
    )
    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    grasp_description: Mapped[GraspDescriptionDAO] = relationship(
        "GraspDescriptionDAO",
        uselist=False,
        foreign_keys=[grasp_description_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "MoveAndPickUpActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class MoveAndPlaceActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[
        pycram.robot_plans.actions.composite.transporting.MoveAndPlaceAction
    ],
):

    __tablename__ = "MoveAndPlaceActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    keep_joint_states: Mapped[builtins.bool] = mapped_column(use_existing_column=True)

    standing_position_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    target_location_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    standing_position: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[standing_position_id],
        post_update=True,
    )
    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    target_location: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[target_location_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "MoveAndPlaceActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class MoveTorsoActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.robot_body.MoveTorsoAction],
):

    __tablename__ = "MoveTorsoActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    torso_state: Mapped[pycram.datastructures.enums.TorsoState] = mapped_column(
        use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "MoveTorsoActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class NavigateActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.navigation.NavigateAction],
):

    __tablename__ = "NavigateActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    keep_joint_states: Mapped[builtins.bool] = mapped_column(use_existing_column=True)

    target_location_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    target_location: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[target_location_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "NavigateActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class OpenActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.container.OpenAction],
):

    __tablename__ = "OpenActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    grasping_prepose_distance: Mapped[builtins.float] = mapped_column(
        use_existing_column=True
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "OpenActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class ParkArmsActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.robot_body.ParkArmsAction],
):

    __tablename__ = "ParkArmsActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ParkArmsActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class PickAndPlaceActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[
        pycram.robot_plans.actions.composite.transporting.PickAndPlaceAction
    ],
):

    __tablename__ = "PickAndPlaceActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    target_location_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    grasp_description_id: Mapped[int] = mapped_column(
        ForeignKey("GraspDescriptionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    target_location: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[target_location_id],
        post_update=True,
    )
    grasp_description: Mapped[GraspDescriptionDAO] = relationship(
        "GraspDescriptionDAO",
        uselist=False,
        foreign_keys=[grasp_description_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "PickAndPlaceActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class PickUpActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.pick_up.PickUpAction],
):

    __tablename__ = "PickUpActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    grasp_description_id: Mapped[int] = mapped_column(
        ForeignKey("GraspDescriptionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    grasp_description: Mapped[GraspDescriptionDAO] = relationship(
        "GraspDescriptionDAO",
        uselist=False,
        foreign_keys=[grasp_description_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "PickUpActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class PlaceActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.placing.PlaceAction],
):

    __tablename__ = "PlaceActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    target_location_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    target_location: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[target_location_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "PlaceActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class PlanMappingDAO(Base, DataAccessObject[pycram.orm.model.PlanMapping]):

    __tablename__ = "PlanMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    nodes: Mapped[typing.List[PlanNodeMappingDAO]] = relationship(
        "PlanNodeMappingDAO",
        foreign_keys="[PlanNodeMappingDAO.planmappingdao_nodes_id]",
        post_update=True,
    )
    edges: Mapped[typing.List[PlanEdgeDAO]] = relationship(
        "PlanEdgeDAO",
        foreign_keys="[PlanEdgeDAO.planmappingdao_edges_id]",
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "PlanMappingDAO",
    }


class LanguagePlanDAO(PlanMappingDAO, DataAccessObject[pycram.language.LanguagePlan]):

    __tablename__ = "LanguagePlanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(PlanMappingDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "LanguagePlanDAO",
        "inherit_condition": database_id == PlanMappingDAO.database_id,
    }


class CodePlanDAO(LanguagePlanDAO, DataAccessObject[pycram.language.CodePlan]):

    __tablename__ = "CodePlanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguagePlanDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "CodePlanDAO",
        "inherit_condition": database_id == LanguagePlanDAO.database_id,
    }


class MonitorPlanDAO(LanguagePlanDAO, DataAccessObject[pycram.language.MonitorPlan]):

    __tablename__ = "MonitorPlanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguagePlanDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "MonitorPlanDAO",
        "inherit_condition": database_id == LanguagePlanDAO.database_id,
    }


class ParallelPlanDAO(LanguagePlanDAO, DataAccessObject[pycram.language.ParallelPlan]):

    __tablename__ = "ParallelPlanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguagePlanDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ParallelPlanDAO",
        "inherit_condition": database_id == LanguagePlanDAO.database_id,
    }


class PlanEdgeDAO(Base, DataAccessObject[pycram.orm.model.PlanEdge]):

    __tablename__ = "PlanEdgeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    planmappingdao_edges_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("PlanMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    parent_id: Mapped[int] = mapped_column(
        ForeignKey("PlanNodeMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    child_id: Mapped[int] = mapped_column(
        ForeignKey("PlanNodeMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    parent: Mapped[PlanNodeMappingDAO] = relationship(
        "PlanNodeMappingDAO", uselist=False, foreign_keys=[parent_id], post_update=True
    )
    child: Mapped[PlanNodeMappingDAO] = relationship(
        "PlanNodeMappingDAO", uselist=False, foreign_keys=[child_id], post_update=True
    )


class PlanNodeMappingDAO(Base, DataAccessObject[pycram.orm.model.PlanNodeMapping]):

    __tablename__ = "PlanNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    status: Mapped[pycram.datastructures.enums.TaskStatus] = mapped_column(
        use_existing_column=True
    )
    start_time: Mapped[typing.Optional[datetime.datetime]] = mapped_column(
        use_existing_column=True
    )
    end_time: Mapped[typing.Optional[datetime.datetime]] = mapped_column(
        use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    planmappingdao_nodes_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("PlanMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "PlanNodeMappingDAO",
    }


class DesignatorNodeMappingDAO(
    PlanNodeMappingDAO, DataAccessObject[pycram.orm.model.DesignatorNodeMapping]
):

    __tablename__ = "DesignatorNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(PlanNodeMappingDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "DesignatorNodeMappingDAO",
        "inherit_condition": database_id == PlanNodeMappingDAO.database_id,
    }


class ActionNodeMappingDAO(
    DesignatorNodeMappingDAO, DataAccessObject[pycram.orm.model.ActionNodeMapping]
):

    __tablename__ = "ActionNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(DesignatorNodeMappingDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ActionNodeMappingDAO",
        "inherit_condition": database_id == DesignatorNodeMappingDAO.database_id,
    }


class MotionNodeMappingDAO(
    DesignatorNodeMappingDAO, DataAccessObject[pycram.orm.model.MotionNodeMapping]
):

    __tablename__ = "MotionNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(DesignatorNodeMappingDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "MotionNodeMappingDAO",
        "inherit_condition": database_id == DesignatorNodeMappingDAO.database_id,
    }


class LanguageNodeDAO(
    PlanNodeMappingDAO, DataAccessObject[pycram.language.LanguageNode]
):

    __tablename__ = "LanguageNodeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(PlanNodeMappingDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    action: Mapped[TypeType] = mapped_column(
        TypeType, nullable=False, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "LanguageNodeDAO",
        "inherit_condition": database_id == PlanNodeMappingDAO.database_id,
    }


class CodeNodeMappingDAO(
    LanguageNodeDAO, DataAccessObject[pycram.orm.model.CodeNodeMapping]
):

    __tablename__ = "CodeNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguageNodeDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "CodeNodeMappingDAO",
        "inherit_condition": database_id == LanguageNodeDAO.database_id,
    }


class ParallelNodeMappingDAO(
    LanguageNodeDAO, DataAccessObject[pycram.orm.model.ParallelNodeMapping]
):

    __tablename__ = "ParallelNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguageNodeDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ParallelNodeMappingDAO",
        "inherit_condition": database_id == LanguageNodeDAO.database_id,
    }


class Point3MappingDAO(
    Base, DataAccessObject[semantic_digital_twin.orm.model.Point3Mapping]
):

    __tablename__ = "Point3MappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    z: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    reference_frame_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    reference_frame: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[reference_frame_id],
        post_update=True,
    )


class PoseDAO(Base, DataAccessObject[pycram.datastructures.pose.Pose]):

    __tablename__ = "PoseDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    position_id: Mapped[int] = mapped_column(
        ForeignKey("Vector3DAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    orientation_id: Mapped[int] = mapped_column(
        ForeignKey("PyCRAMQuaternionMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    position: Mapped[Vector3DAO] = relationship(
        "Vector3DAO", uselist=False, foreign_keys=[position_id], post_update=True
    )
    orientation: Mapped[PyCRAMQuaternionMappingDAO] = relationship(
        "PyCRAMQuaternionMappingDAO",
        uselist=False,
        foreign_keys=[orientation_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "PoseDAO",
    }


class PoseStampedDAO(Base, DataAccessObject[pycram.datastructures.pose.PoseStamped]):

    __tablename__ = "PoseStampedDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    pose_id: Mapped[int] = mapped_column(
        ForeignKey("PoseDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    header_id: Mapped[int] = mapped_column(
        ForeignKey("HeaderDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    pose: Mapped[PoseDAO] = relationship(
        "PoseDAO", uselist=False, foreign_keys=[pose_id], post_update=True
    )
    header: Mapped[HeaderDAO] = relationship(
        "HeaderDAO", uselist=False, foreign_keys=[header_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "PoseStampedDAO",
    }


class GraspPoseDAO(
    PoseStampedDAO, DataAccessObject[pycram.datastructures.pose.GraspPose]
):

    __tablename__ = "GraspPoseDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(PoseStampedDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )

    grasp_description_id: Mapped[int] = mapped_column(
        ForeignKey("GraspDescriptionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    grasp_description: Mapped[GraspDescriptionDAO] = relationship(
        "GraspDescriptionDAO",
        uselist=False,
        foreign_keys=[grasp_description_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "GraspPoseDAO",
        "inherit_condition": database_id == PoseStampedDAO.database_id,
    }


class PouringActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.composite.tool_based.PouringAction],
):

    __tablename__ = "PouringActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    technique: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )
    angle: Mapped[typing.Optional[builtins.float]] = mapped_column(
        use_existing_column=True
    )

    object__id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    tool_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object__id], post_update=True
    )
    tool: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[tool_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PouringActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class PreferredGraspAlignmentDAO(
    Base, DataAccessObject[pycram.datastructures.grasp.PreferredGraspAlignment]
):

    __tablename__ = "PreferredGraspAlignmentDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    preferred_axis: Mapped[
        typing.Optional[pycram.datastructures.enums.AxisIdentifier]
    ] = mapped_column(use_existing_column=True)
    with_vertical_alignment: Mapped[builtins.bool] = mapped_column(
        use_existing_column=True
    )
    with_rotated_gripper: Mapped[builtins.bool] = mapped_column(
        use_existing_column=True
    )


class PrefixedNameDAO(
    Base,
    DataAccessObject[semantic_digital_twin.datastructures.prefixed_name.PrefixedName],
):

    __tablename__ = "PrefixedNameDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    name: Mapped[builtins.str] = mapped_column(String(255), use_existing_column=True)
    prefix: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )

    worldstatemappingdao_names_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("WorldStateMappingDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )


class PyCRAMQuaternionMappingDAO(
    Base, DataAccessObject[pycram.orm.model.PyCRAMQuaternionMapping]
):

    __tablename__ = "PyCRAMQuaternionMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    z: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    w: Mapped[builtins.float] = mapped_column(use_existing_column=True)


class QuaternionMappingDAO(
    Base, DataAccessObject[semantic_digital_twin.orm.model.QuaternionMapping]
):

    __tablename__ = "QuaternionMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    z: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    w: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    reference_frame_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    reference_frame: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[reference_frame_id],
        post_update=True,
    )


class ReachToPickUpActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.pick_up.ReachToPickUpAction],
):

    __tablename__ = "ReachToPickUpActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    grasp_description_id: Mapped[int] = mapped_column(
        ForeignKey("GraspDescriptionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    grasp_description: Mapped[GraspDescriptionDAO] = relationship(
        "GraspDescriptionDAO",
        uselist=False,
        foreign_keys=[grasp_description_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ReachToPickUpActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class RepeatPlanDAO(LanguagePlanDAO, DataAccessObject[pycram.language.RepeatPlan]):

    __tablename__ = "RepeatPlanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguagePlanDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "RepeatPlanDAO",
        "inherit_condition": database_id == LanguagePlanDAO.database_id,
    }


class ResolvedActionNodeMappingDAO(
    DesignatorNodeMappingDAO,
    DataAccessObject[pycram.orm.model.ResolvedActionNodeMapping],
):

    __tablename__ = "ResolvedActionNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(DesignatorNodeMappingDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ResolvedActionNodeMappingDAO",
        "inherit_condition": database_id == DesignatorNodeMappingDAO.database_id,
    }


class RotationMatrixMappingDAO(
    Base, DataAccessObject[semantic_digital_twin.orm.model.RotationMatrixMapping]
):

    __tablename__ = "RotationMatrixMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    rotation_id: Mapped[int] = mapped_column(
        ForeignKey("QuaternionMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    reference_frame_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    rotation: Mapped[QuaternionMappingDAO] = relationship(
        "QuaternionMappingDAO",
        uselist=False,
        foreign_keys=[rotation_id],
        post_update=True,
    )
    reference_frame: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[reference_frame_id],
        post_update=True,
    )


class ScaleDAO(
    Base, DataAccessObject[semantic_digital_twin.world_description.geometry.Scale]
):

    __tablename__ = "ScaleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    z: Mapped[builtins.float] = mapped_column(use_existing_column=True)


class SearchActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.composite.searching.SearchAction],
):

    __tablename__ = "SearchActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    object_type: Mapped[TypeType] = mapped_column(
        TypeType, nullable=False, use_existing_column=True
    )

    target_location_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    target_location: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[target_location_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "SearchActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class SequentialNodeDAO(
    LanguageNodeDAO, DataAccessObject[pycram.language.SequentialNode]
):

    __tablename__ = "SequentialNodeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguageNodeDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "SequentialNodeDAO",
        "inherit_condition": database_id == LanguageNodeDAO.database_id,
    }


class MonitorNodeMappingDAO(
    SequentialNodeDAO, DataAccessObject[pycram.orm.model.MonitorNodeMapping]
):

    __tablename__ = "MonitorNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SequentialNodeDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "MonitorNodeMappingDAO",
        "inherit_condition": database_id == SequentialNodeDAO.database_id,
    }


class RepeatNodeDAO(SequentialNodeDAO, DataAccessObject[pycram.language.RepeatNode]):

    __tablename__ = "RepeatNodeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SequentialNodeDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    repeat: Mapped[builtins.int] = mapped_column(use_existing_column=True)

    __mapper_args__ = {
        "polymorphic_identity": "RepeatNodeDAO",
        "inherit_condition": database_id == SequentialNodeDAO.database_id,
    }


class SequentialPlanDAO(
    LanguagePlanDAO, DataAccessObject[pycram.language.SequentialPlan]
):

    __tablename__ = "SequentialPlanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguagePlanDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "SequentialPlanDAO",
        "inherit_condition": database_id == LanguagePlanDAO.database_id,
    }


class SetGripperActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.core.robot_body.SetGripperAction],
):

    __tablename__ = "SetGripperActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    gripper: Mapped[pycram.datastructures.enums.Arms] = mapped_column(
        use_existing_column=True
    )
    motion: Mapped[pycram.datastructures.enums.GripperState] = mapped_column(
        use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SetGripperActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class ShapeDAO(
    Base, DataAccessObject[semantic_digital_twin.world_description.geometry.Shape]
):

    __tablename__ = "ShapeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    origin_id: Mapped[int] = mapped_column(
        ForeignKey("TransformationMatrixMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    color_id: Mapped[int] = mapped_column(
        ForeignKey("ColorDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    shapecollectiondao_shapes_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("ShapeCollectionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    origin: Mapped[TransformationMatrixMappingDAO] = relationship(
        "TransformationMatrixMappingDAO",
        uselist=False,
        foreign_keys=[origin_id],
        post_update=True,
    )
    color: Mapped[ColorDAO] = relationship(
        "ColorDAO", uselist=False, foreign_keys=[color_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "ShapeDAO",
    }


class BoxDAO(
    ShapeDAO, DataAccessObject[semantic_digital_twin.world_description.geometry.Box]
):

    __tablename__ = "BoxDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ShapeDAO.database_id), primary_key=True, use_existing_column=True
    )

    scale_id: Mapped[int] = mapped_column(
        ForeignKey("ScaleDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    scale: Mapped[ScaleDAO] = relationship(
        "ScaleDAO", uselist=False, foreign_keys=[scale_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BoxDAO",
        "inherit_condition": database_id == ShapeDAO.database_id,
    }


class CylinderDAO(
    ShapeDAO,
    DataAccessObject[semantic_digital_twin.world_description.geometry.Cylinder],
):

    __tablename__ = "CylinderDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ShapeDAO.database_id), primary_key=True, use_existing_column=True
    )

    width: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    height: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    __mapper_args__ = {
        "polymorphic_identity": "CylinderDAO",
        "inherit_condition": database_id == ShapeDAO.database_id,
    }


class MeshDAO(
    ShapeDAO, DataAccessObject[semantic_digital_twin.world_description.geometry.Mesh]
):

    __tablename__ = "MeshDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ShapeDAO.database_id), primary_key=True, use_existing_column=True
    )

    scale_id: Mapped[int] = mapped_column(
        ForeignKey("ScaleDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    scale: Mapped[ScaleDAO] = relationship(
        "ScaleDAO", uselist=False, foreign_keys=[scale_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "MeshDAO",
        "inherit_condition": database_id == ShapeDAO.database_id,
    }


class FileMeshDAO(
    MeshDAO, DataAccessObject[semantic_digital_twin.world_description.geometry.FileMesh]
):

    __tablename__ = "FileMeshDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(MeshDAO.database_id), primary_key=True, use_existing_column=True
    )

    filename: Mapped[builtins.str] = mapped_column(
        String(255), use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "FileMeshDAO",
        "inherit_condition": database_id == MeshDAO.database_id,
    }


class ShapeCollectionDAO(
    Base,
    DataAccessObject[
        semantic_digital_twin.world_description.shape_collection.ShapeCollection
    ],
):

    __tablename__ = "ShapeCollectionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    reference_frame_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    shapes: Mapped[typing.List[ShapeDAO]] = relationship(
        "ShapeDAO",
        foreign_keys="[ShapeDAO.shapecollectiondao_shapes_id]",
        post_update=True,
    )
    reference_frame: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[reference_frame_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "ShapeCollectionDAO",
    }


class BoundingBoxCollectionDAO(
    ShapeCollectionDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.shape_collection.BoundingBoxCollection
    ],
):

    __tablename__ = "BoundingBoxCollectionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ShapeCollectionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "BoundingBoxCollectionDAO",
        "inherit_condition": database_id == ShapeCollectionDAO.database_id,
    }


class SpatialRelationDAO(
    Base, DataAccessObject[semantic_digital_twin.reasoning.predicates.SpatialRelation]
):

    __tablename__ = "SpatialRelationDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    other_id: Mapped[int] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[body_id],
        post_update=True,
    )
    other: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[other_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "SpatialRelationDAO",
    }


class InsideOfDAO(
    SpatialRelationDAO,
    DataAccessObject[semantic_digital_twin.reasoning.predicates.InsideOf],
):

    __tablename__ = "InsideOfDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    containment_ratio: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    __mapper_args__ = {
        "polymorphic_identity": "InsideOfDAO",
        "inherit_condition": database_id == SpatialRelationDAO.database_id,
    }


class SphereDAO(
    ShapeDAO, DataAccessObject[semantic_digital_twin.world_description.geometry.Sphere]
):

    __tablename__ = "SphereDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ShapeDAO.database_id), primary_key=True, use_existing_column=True
    )

    radius: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    __mapper_args__ = {
        "polymorphic_identity": "SphereDAO",
        "inherit_condition": database_id == ShapeDAO.database_id,
    }


class TransformDAO(PoseDAO, DataAccessObject[pycram.datastructures.pose.Transform]):

    __tablename__ = "TransformDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(PoseDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "TransformDAO",
        "inherit_condition": database_id == PoseDAO.database_id,
    }


class TransformStampedDAO(
    PoseStampedDAO, DataAccessObject[pycram.datastructures.pose.TransformStamped]
):

    __tablename__ = "TransformStampedDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(PoseStampedDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    child_frame_id_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    child_frame_id: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[child_frame_id_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "TransformStampedDAO",
        "inherit_condition": database_id == PoseStampedDAO.database_id,
    }


class TransformationMatrixMappingDAO(
    Base, DataAccessObject[semantic_digital_twin.orm.model.TransformationMatrixMapping]
):

    __tablename__ = "TransformationMatrixMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    position_id: Mapped[int] = mapped_column(
        ForeignKey("Point3MappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    rotation_id: Mapped[int] = mapped_column(
        ForeignKey("QuaternionMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    reference_frame_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    child_frame_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    position: Mapped[Point3MappingDAO] = relationship(
        "Point3MappingDAO", uselist=False, foreign_keys=[position_id], post_update=True
    )
    rotation: Mapped[QuaternionMappingDAO] = relationship(
        "QuaternionMappingDAO",
        uselist=False,
        foreign_keys=[rotation_id],
        post_update=True,
    )
    reference_frame: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[reference_frame_id],
        post_update=True,
    )
    child_frame: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[child_frame_id],
        post_update=True,
    )


class TransportActionDAO(
    ActionDescriptionDAO,
    DataAccessObject[pycram.robot_plans.actions.composite.transporting.TransportAction],
):

    __tablename__ = "TransportActionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActionDescriptionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    arm: Mapped[typing.Optional[pycram.datastructures.enums.Arms]] = mapped_column(
        use_existing_column=True
    )
    place_rotation_agnostic: Mapped[typing.Optional[builtins.bool]] = mapped_column(
        use_existing_column=True
    )

    object_designator_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    target_location_id: Mapped[int] = mapped_column(
        ForeignKey("PoseStampedDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    object_designator: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[object_designator_id], post_update=True
    )
    target_location: Mapped[PoseStampedDAO] = relationship(
        "PoseStampedDAO",
        uselist=False,
        foreign_keys=[target_location_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "TransportActionDAO",
        "inherit_condition": database_id == ActionDescriptionDAO.database_id,
    }


class TriangleMeshDAO(
    MeshDAO,
    DataAccessObject[semantic_digital_twin.world_description.geometry.TriangleMesh],
):

    __tablename__ = "TriangleMeshDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(MeshDAO.database_id), primary_key=True, use_existing_column=True
    )

    mesh: Mapped[typing.Optional[semantic_digital_twin.orm.model.TrimeshType]] = (
        mapped_column(
            semantic_digital_twin.orm.model.TrimeshType,
            nullable=True,
            use_existing_column=True,
        )
    )

    __mapper_args__ = {
        "polymorphic_identity": "TriangleMeshDAO",
        "inherit_condition": database_id == MeshDAO.database_id,
    }


class TryAllNodeMappingDAO(
    ParallelNodeMappingDAO, DataAccessObject[pycram.orm.model.TryAllNodeMapping]
):

    __tablename__ = "TryAllNodeMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ParallelNodeMappingDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "TryAllNodeMappingDAO",
        "inherit_condition": database_id == ParallelNodeMappingDAO.database_id,
    }


class TryAllPLanDAO(ParallelPlanDAO, DataAccessObject[pycram.language.TryAllPLan]):

    __tablename__ = "TryAllPLanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ParallelPlanDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "TryAllPLanDAO",
        "inherit_condition": database_id == ParallelPlanDAO.database_id,
    }


class TryInOrderMappingDAO(
    SequentialNodeDAO, DataAccessObject[pycram.orm.model.TryInOrderMapping]
):

    __tablename__ = "TryInOrderMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SequentialNodeDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "TryInOrderMappingDAO",
        "inherit_condition": database_id == SequentialNodeDAO.database_id,
    }


class TryInOrderPlanDAO(
    LanguagePlanDAO, DataAccessObject[pycram.language.TryInOrderPlan]
):

    __tablename__ = "TryInOrderPlanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LanguagePlanDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "TryInOrderPlanDAO",
        "inherit_condition": database_id == LanguagePlanDAO.database_id,
    }


class Vector3MappingDAO(
    Base, DataAccessObject[semantic_digital_twin.orm.model.Vector3Mapping]
):

    __tablename__ = "Vector3MappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    z: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    reference_frame_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    reference_frame: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[reference_frame_id],
        post_update=True,
    )


class Vector3DAO(Base, DataAccessObject[pycram.datastructures.pose.Vector3]):

    __tablename__ = "Vector3DAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    x: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    y: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    z: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "Vector3DAO",
    }


class Vector3StampedDAO(
    Vector3DAO, DataAccessObject[pycram.datastructures.pose.Vector3Stamped]
):

    __tablename__ = "Vector3StampedDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(Vector3DAO.database_id), primary_key=True, use_existing_column=True
    )

    header_id: Mapped[int] = mapped_column(
        ForeignKey("HeaderDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    header: Mapped[HeaderDAO] = relationship(
        "HeaderDAO", uselist=False, foreign_keys=[header_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "Vector3StampedDAO",
        "inherit_condition": database_id == Vector3DAO.database_id,
    }


class ViewDependentSpatialRelationDAO(
    SpatialRelationDAO,
    DataAccessObject[
        semantic_digital_twin.reasoning.predicates.ViewDependentSpatialRelation
    ],
):

    __tablename__ = "ViewDependentSpatialRelationDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    eps: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    spatial_relation_result: Mapped[builtins.bool] = mapped_column(
        use_existing_column=True
    )

    point_of_semantic_annotation_id: Mapped[int] = mapped_column(
        ForeignKey("TransformationMatrixMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    point_of_semantic_annotation: Mapped[TransformationMatrixMappingDAO] = relationship(
        "TransformationMatrixMappingDAO",
        uselist=False,
        foreign_keys=[point_of_semantic_annotation_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ViewDependentSpatialRelationDAO",
        "inherit_condition": database_id == SpatialRelationDAO.database_id,
    }


class AboveDAO(
    ViewDependentSpatialRelationDAO,
    DataAccessObject[semantic_digital_twin.reasoning.predicates.Above],
):

    __tablename__ = "AboveDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ViewDependentSpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "AboveDAO",
        "inherit_condition": database_id == ViewDependentSpatialRelationDAO.database_id,
    }


class BehindDAO(
    ViewDependentSpatialRelationDAO,
    DataAccessObject[semantic_digital_twin.reasoning.predicates.Behind],
):

    __tablename__ = "BehindDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ViewDependentSpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "BehindDAO",
        "inherit_condition": database_id == ViewDependentSpatialRelationDAO.database_id,
    }


class BelowDAO(
    ViewDependentSpatialRelationDAO,
    DataAccessObject[semantic_digital_twin.reasoning.predicates.Below],
):

    __tablename__ = "BelowDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ViewDependentSpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "BelowDAO",
        "inherit_condition": database_id == ViewDependentSpatialRelationDAO.database_id,
    }


class InFrontOfDAO(
    ViewDependentSpatialRelationDAO,
    DataAccessObject[semantic_digital_twin.reasoning.predicates.InFrontOf],
):

    __tablename__ = "InFrontOfDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ViewDependentSpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "InFrontOfDAO",
        "inherit_condition": database_id == ViewDependentSpatialRelationDAO.database_id,
    }


class LeftOfDAO(
    ViewDependentSpatialRelationDAO,
    DataAccessObject[semantic_digital_twin.reasoning.predicates.LeftOf],
):

    __tablename__ = "LeftOfDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ViewDependentSpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "LeftOfDAO",
        "inherit_condition": database_id == ViewDependentSpatialRelationDAO.database_id,
    }


class RightOfDAO(
    ViewDependentSpatialRelationDAO,
    DataAccessObject[semantic_digital_twin.reasoning.predicates.RightOf],
):

    __tablename__ = "RightOfDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ViewDependentSpatialRelationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "RightOfDAO",
        "inherit_condition": database_id == ViewDependentSpatialRelationDAO.database_id,
    }


class WorldMappingDAO(
    Base, DataAccessObject[semantic_digital_twin.orm.model.WorldMapping]
):

    __tablename__ = "WorldMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    name: Mapped[typing.Optional[builtins.str]] = mapped_column(
        String(255), use_existing_column=True
    )

    state_id: Mapped[int] = mapped_column(
        ForeignKey("WorldStateMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    kinematic_structure_entities: Mapped[typing.List[KinematicStructureEntityDAO]] = (
        relationship(
            "KinematicStructureEntityDAO",
            foreign_keys="[KinematicStructureEntityDAO.worldmappingdao_kinematic_structure_entities_id]",
            post_update=True,
        )
    )
    connections: Mapped[typing.List[ConnectionDAO]] = relationship(
        "ConnectionDAO",
        foreign_keys="[ConnectionDAO.worldmappingdao_connections_id]",
        post_update=True,
    )
    semantic_annotations: Mapped[typing.List[SemanticAnnotationDAO]] = relationship(
        "SemanticAnnotationDAO",
        foreign_keys="[SemanticAnnotationDAO.worldmappingdao_semantic_annotations_id]",
        post_update=True,
    )
    degrees_of_freedom: Mapped[typing.List[DegreeOfFreedomMappingDAO]] = relationship(
        "DegreeOfFreedomMappingDAO",
        foreign_keys="[DegreeOfFreedomMappingDAO.worldmappingdao_degrees_of_freedom_id]",
        post_update=True,
    )
    state: Mapped[WorldStateMappingDAO] = relationship(
        "WorldStateMappingDAO", uselist=False, foreign_keys=[state_id], post_update=True
    )


class WorldEntityDAO(
    Base,
    DataAccessObject[semantic_digital_twin.world_description.world_entity.WorldEntity],
):

    __tablename__ = "WorldEntityDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    polymorphic_type: Mapped[str] = mapped_column(
        String(255), nullable=False, use_existing_column=True
    )

    name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[name_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_on": "polymorphic_type",
        "polymorphic_identity": "WorldEntityDAO",
    }


class ConnectionDAO(
    WorldEntityDAO,
    DataAccessObject[semantic_digital_twin.world_description.world_entity.Connection],
):

    __tablename__ = "ConnectionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(WorldEntityDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    worldmappingdao_connections_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("WorldMappingDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )
    parent_id: Mapped[int] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    child_id: Mapped[int] = mapped_column(
        ForeignKey("KinematicStructureEntityDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    parent_T_connection_expression_id: Mapped[int] = mapped_column(
        ForeignKey("TransformationMatrixMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    connection_T_child_expression_id: Mapped[int] = mapped_column(
        ForeignKey("TransformationMatrixMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    parent: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[parent_id],
        post_update=True,
    )
    child: Mapped[KinematicStructureEntityDAO] = relationship(
        "KinematicStructureEntityDAO",
        uselist=False,
        foreign_keys=[child_id],
        post_update=True,
    )
    parent_T_connection_expression: Mapped[TransformationMatrixMappingDAO] = (
        relationship(
            "TransformationMatrixMappingDAO",
            uselist=False,
            foreign_keys=[parent_T_connection_expression_id],
            post_update=True,
        )
    )
    connection_T_child_expression: Mapped[TransformationMatrixMappingDAO] = (
        relationship(
            "TransformationMatrixMappingDAO",
            uselist=False,
            foreign_keys=[connection_T_child_expression_id],
            post_update=True,
        )
    )

    __mapper_args__ = {
        "polymorphic_identity": "ConnectionDAO",
        "inherit_condition": database_id == WorldEntityDAO.database_id,
    }


class ActiveConnectionDAO(
    ConnectionDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.connections.ActiveConnection
    ],
):

    __tablename__ = "ActiveConnectionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ConnectionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    frozen_for_collision_avoidance: Mapped[builtins.bool] = mapped_column(
        use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ActiveConnectionDAO",
        "inherit_condition": database_id == ConnectionDAO.database_id,
    }


class ActiveConnection1DOFDAO(
    ActiveConnectionDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.connections.ActiveConnection1DOF
    ],
):

    __tablename__ = "ActiveConnection1DOFDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActiveConnectionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    multiplier: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    offset: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    axis_id: Mapped[int] = mapped_column(
        ForeignKey("Vector3MappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    dof_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    axis: Mapped[Vector3MappingDAO] = relationship(
        "Vector3MappingDAO", uselist=False, foreign_keys=[axis_id], post_update=True
    )
    dof_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[dof_name_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ActiveConnection1DOFDAO",
        "inherit_condition": database_id == ActiveConnectionDAO.database_id,
    }


class PrismaticConnectionDAO(
    ActiveConnection1DOFDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.connections.PrismaticConnection
    ],
):

    __tablename__ = "PrismaticConnectionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActiveConnection1DOFDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "PrismaticConnectionDAO",
        "inherit_condition": database_id == ActiveConnection1DOFDAO.database_id,
    }


class RevoluteConnectionDAO(
    ActiveConnection1DOFDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.connections.RevoluteConnection
    ],
):

    __tablename__ = "RevoluteConnectionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActiveConnection1DOFDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "RevoluteConnectionDAO",
        "inherit_condition": database_id == ActiveConnection1DOFDAO.database_id,
    }


class OmniDriveDAO(
    ActiveConnectionDAO,
    DataAccessObject[semantic_digital_twin.world_description.connections.OmniDrive],
):

    __tablename__ = "OmniDriveDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ActiveConnectionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    x_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    y_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    roll_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    pitch_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    yaw_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    x_velocity_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    y_velocity_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    x_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[x_name_id], post_update=True
    )
    y_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[y_name_id], post_update=True
    )
    roll_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[roll_name_id], post_update=True
    )
    pitch_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[pitch_name_id], post_update=True
    )
    yaw_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[yaw_name_id], post_update=True
    )
    x_velocity_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO",
        uselist=False,
        foreign_keys=[x_velocity_name_id],
        post_update=True,
    )
    y_velocity_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO",
        uselist=False,
        foreign_keys=[y_velocity_name_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "OmniDriveDAO",
        "inherit_condition": database_id == ActiveConnectionDAO.database_id,
    }


class Connection6DoFDAO(
    ConnectionDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.connections.Connection6DoF
    ],
):

    __tablename__ = "Connection6DoFDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ConnectionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    x_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    y_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    z_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    qx_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    qy_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    qz_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    qw_name_id: Mapped[int] = mapped_column(
        ForeignKey("PrefixedNameDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    x_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[x_name_id], post_update=True
    )
    y_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[y_name_id], post_update=True
    )
    z_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[z_name_id], post_update=True
    )
    qx_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[qx_name_id], post_update=True
    )
    qy_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[qy_name_id], post_update=True
    )
    qz_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[qz_name_id], post_update=True
    )
    qw_name: Mapped[PrefixedNameDAO] = relationship(
        "PrefixedNameDAO", uselist=False, foreign_keys=[qw_name_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "Connection6DoFDAO",
        "inherit_condition": database_id == ConnectionDAO.database_id,
    }


class FixedConnectionDAO(
    ConnectionDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.connections.FixedConnection
    ],
):

    __tablename__ = "FixedConnectionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ConnectionDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "FixedConnectionDAO",
        "inherit_condition": database_id == ConnectionDAO.database_id,
    }


class DegreeOfFreedomMappingDAO(
    WorldEntityDAO,
    DataAccessObject[semantic_digital_twin.orm.model.DegreeOfFreedomMapping],
):

    __tablename__ = "DegreeOfFreedomMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(WorldEntityDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    lower_limits: Mapped[typing.List[builtins.float]] = mapped_column(
        JSON, nullable=False, use_existing_column=True
    )
    upper_limits: Mapped[typing.List[builtins.float]] = mapped_column(
        JSON, nullable=False, use_existing_column=True
    )

    worldmappingdao_degrees_of_freedom_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("WorldMappingDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )

    __mapper_args__ = {
        "polymorphic_identity": "DegreeOfFreedomMappingDAO",
        "inherit_condition": database_id == WorldEntityDAO.database_id,
    }


class KinematicStructureEntityDAO(
    WorldEntityDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.world_entity.KinematicStructureEntity
    ],
):

    __tablename__ = "KinematicStructureEntityDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(WorldEntityDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    index: Mapped[typing.Optional[builtins.int]] = mapped_column(
        use_existing_column=True
    )

    worldmappingdao_kinematic_structure_entities_id: Mapped[
        typing.Optional[builtins.int]
    ] = mapped_column(
        ForeignKey("WorldMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "KinematicStructureEntityDAO",
        "inherit_condition": database_id == WorldEntityDAO.database_id,
    }


class BodyDAO(
    KinematicStructureEntityDAO,
    DataAccessObject[semantic_digital_twin.world_description.world_entity.Body],
):

    __tablename__ = "BodyDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(KinematicStructureEntityDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    visual_id: Mapped[int] = mapped_column(
        ForeignKey("ShapeCollectionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    collision_id: Mapped[int] = mapped_column(
        ForeignKey("ShapeCollectionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    collision_config_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("CollisionCheckingConfigDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    temp_collision_config_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("CollisionCheckingConfigDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    visual: Mapped[ShapeCollectionDAO] = relationship(
        "ShapeCollectionDAO", uselist=False, foreign_keys=[visual_id], post_update=True
    )
    collision: Mapped[ShapeCollectionDAO] = relationship(
        "ShapeCollectionDAO",
        uselist=False,
        foreign_keys=[collision_id],
        post_update=True,
    )
    collision_config: Mapped[CollisionCheckingConfigDAO] = relationship(
        "CollisionCheckingConfigDAO",
        uselist=False,
        foreign_keys=[collision_config_id],
        post_update=True,
    )
    temp_collision_config: Mapped[CollisionCheckingConfigDAO] = relationship(
        "CollisionCheckingConfigDAO",
        uselist=False,
        foreign_keys=[temp_collision_config_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "BodyDAO",
        "inherit_condition": database_id == KinematicStructureEntityDAO.database_id,
    }


class RegionDAO(
    KinematicStructureEntityDAO,
    DataAccessObject[semantic_digital_twin.world_description.world_entity.Region],
):

    __tablename__ = "RegionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(KinematicStructureEntityDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    area_id: Mapped[int] = mapped_column(
        ForeignKey("ShapeCollectionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    area: Mapped[ShapeCollectionDAO] = relationship(
        "ShapeCollectionDAO", uselist=False, foreign_keys=[area_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "RegionDAO",
        "inherit_condition": database_id == KinematicStructureEntityDAO.database_id,
    }


class SemanticAnnotationDAO(
    WorldEntityDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.world_entity.SemanticAnnotation
    ],
):

    __tablename__ = "SemanticAnnotationDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(WorldEntityDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    worldmappingdao_semantic_annotations_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("WorldMappingDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )

    __mapper_args__ = {
        "polymorphic_identity": "SemanticAnnotationDAO",
        "inherit_condition": database_id == WorldEntityDAO.database_id,
    }


class DoubleDoorDAO(
    SemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.DoubleDoor
    ],
):

    __tablename__ = "DoubleDoorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    left_door_id: Mapped[int] = mapped_column(
        ForeignKey("DoorDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    right_door_id: Mapped[int] = mapped_column(
        ForeignKey("DoorDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    left_door: Mapped[DoorDAO] = relationship(
        "DoorDAO", uselist=False, foreign_keys=[left_door_id], post_update=True
    )
    right_door: Mapped[DoorDAO] = relationship(
        "DoorDAO", uselist=False, foreign_keys=[right_door_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DoubleDoorDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class DrawerDAO(
    SemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Drawer
    ],
):

    __tablename__ = "DrawerDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    container_id: Mapped[int] = mapped_column(
        ForeignKey("ContainerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    handle_id: Mapped[int] = mapped_column(
        ForeignKey("HandleDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    hasdrawersdao_drawers_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("HasDrawersDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    cabinetdao_drawers_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("CabinetDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    dresserdao_drawers_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("DresserDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    wardrobedao_drawers_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("WardrobeDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    container: Mapped[ContainerDAO] = relationship(
        "ContainerDAO", uselist=False, foreign_keys=[container_id], post_update=True
    )
    handle: Mapped[HandleDAO] = relationship(
        "HandleDAO", uselist=False, foreign_keys=[handle_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DrawerDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class FridgeDAO(
    SemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Fridge
    ],
):

    __tablename__ = "FridgeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    container_id: Mapped[int] = mapped_column(
        ForeignKey("ContainerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    door_id: Mapped[int] = mapped_column(
        ForeignKey("DoorDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    container: Mapped[ContainerDAO] = relationship(
        "ContainerDAO", uselist=False, foreign_keys=[container_id], post_update=True
    )
    door: Mapped[DoorDAO] = relationship(
        "DoorDAO", uselist=False, foreign_keys=[door_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "FridgeDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class FurnitureDAO(
    SemanticAnnotationDAO,
    DataAccessObject[semantic_digital_twin.semantic_annotations.mixins.Furniture],
):

    __tablename__ = "FurnitureDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "FurnitureDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class HasBodyDAO(
    SemanticAnnotationDAO,
    DataAccessObject[semantic_digital_twin.semantic_annotations.mixins.HasBody],
):

    __tablename__ = "HasBodyDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "HasBodyDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class BaseballDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Baseball
    ],
):

    __tablename__ = "BaseballDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BaseballDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class BedDAO(
    FurnitureDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Bed
    ],
):

    __tablename__ = "BedDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FurnitureDAO.database_id), primary_key=True, use_existing_column=True
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BedDAO",
        "inherit_condition": database_id == FurnitureDAO.database_id,
    }


class BookDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Book
    ],
):

    __tablename__ = "BookDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    book_front_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("BookFrontDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    book_front: Mapped[BookFrontDAO] = relationship(
        "BookFrontDAO", uselist=False, foreign_keys=[book_front_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BookDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class BookFrontDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.BookFront
    ],
):

    __tablename__ = "BookFrontDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BookFrontDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class ChairDAO(
    FurnitureDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Chair
    ],
):

    __tablename__ = "ChairDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FurnitureDAO.database_id), primary_key=True, use_existing_column=True
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ChairDAO",
        "inherit_condition": database_id == FurnitureDAO.database_id,
    }


class ArmchairDAO(
    ChairDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Armchair
    ],
):

    __tablename__ = "ArmchairDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ChairDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ArmchairDAO",
        "inherit_condition": database_id == ChairDAO.database_id,
    }


class OfficeChairDAO(
    ChairDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.OfficeChair
    ],
):

    __tablename__ = "OfficeChairDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ChairDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "OfficeChairDAO",
        "inherit_condition": database_id == ChairDAO.database_id,
    }


class ClothDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Cloth
    ],
):

    __tablename__ = "ClothDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ClothDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class ContainerDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Container
    ],
):

    __tablename__ = "ContainerDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ContainerDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class BottleDAO(
    ContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Bottle
    ],
):

    __tablename__ = "BottleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ContainerDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BottleDAO",
        "inherit_condition": database_id == ContainerDAO.database_id,
    }


class MustardBottleDAO(
    BottleDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.MustardBottle
    ],
):

    __tablename__ = "MustardBottleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(BottleDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "MustardBottleDAO",
        "inherit_condition": database_id == BottleDAO.database_id,
    }


class SoapBottleDAO(
    BottleDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.SoapBottle
    ],
):

    __tablename__ = "SoapBottleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(BottleDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SoapBottleDAO",
        "inherit_condition": database_id == BottleDAO.database_id,
    }


class WineBottleDAO(
    BottleDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.WineBottle
    ],
):

    __tablename__ = "WineBottleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(BottleDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "WineBottleDAO",
        "inherit_condition": database_id == BottleDAO.database_id,
    }


class GarbageBinDAO(
    ContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.GarbageBin
    ],
):

    __tablename__ = "GarbageBinDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ContainerDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "GarbageBinDAO",
        "inherit_condition": database_id == ContainerDAO.database_id,
    }


class ProcthorBoxDAO(
    ContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.ProcthorBox
    ],
):

    __tablename__ = "ProcthorBoxDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ContainerDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ProcthorBoxDAO",
        "inherit_condition": database_id == ContainerDAO.database_id,
    }


class CookingContainerDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.CookingContainer
    ],
):

    __tablename__ = "CookingContainerDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CookingContainerDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class KettleDAO(
    CookingContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Kettle
    ],
):

    __tablename__ = "KettleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(CookingContainerDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "KettleDAO",
        "inherit_condition": database_id == CookingContainerDAO.database_id,
    }


class PanDAO(
    CookingContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Pan
    ],
):

    __tablename__ = "PanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(CookingContainerDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "PanDAO",
        "inherit_condition": database_id == CookingContainerDAO.database_id,
    }


class PotDAO(
    CookingContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Pot
    ],
):

    __tablename__ = "PotDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(CookingContainerDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "PotDAO",
        "inherit_condition": database_id == CookingContainerDAO.database_id,
    }


class CuttleryDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Cuttlery
    ],
):

    __tablename__ = "CuttleryDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CuttleryDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class ForkDAO(
    CuttleryDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Fork
    ],
):

    __tablename__ = "ForkDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(CuttleryDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ForkDAO",
        "inherit_condition": database_id == CuttleryDAO.database_id,
    }


class KnifeDAO(
    CuttleryDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Knife
    ],
):

    __tablename__ = "KnifeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(CuttleryDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "KnifeDAO",
        "inherit_condition": database_id == CuttleryDAO.database_id,
    }


class SpoonDAO(
    CuttleryDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Spoon
    ],
):

    __tablename__ = "SpoonDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(CuttleryDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SpoonDAO",
        "inherit_condition": database_id == CuttleryDAO.database_id,
    }


class DecorDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Decor
    ],
):

    __tablename__ = "DecorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DecorDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class WallDecorDAO(
    DecorDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.WallDecor
    ],
):

    __tablename__ = "WallDecorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(DecorDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "WallDecorDAO",
        "inherit_condition": database_id == DecorDAO.database_id,
    }


class PosterDAO(
    WallDecorDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Poster
    ],
):

    __tablename__ = "PosterDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(WallDecorDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PosterDAO",
        "inherit_condition": database_id == WallDecorDAO.database_id,
    }


class DoorDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Door
    ],
):

    __tablename__ = "DoorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    handle_id: Mapped[int] = mapped_column(
        ForeignKey("HandleDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    hasdoorsdao_doors_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("HasDoorsDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    handle: Mapped[HandleDAO] = relationship(
        "HandleDAO", uselist=False, foreign_keys=[handle_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DoorDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class DrinkingContainerDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.DrinkingContainer
    ],
):

    __tablename__ = "DrinkingContainerDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DrinkingContainerDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class CupDAO(
    DrinkingContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Cup
    ],
):

    __tablename__ = "CupDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(DrinkingContainerDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "CupDAO",
        "inherit_condition": database_id == DrinkingContainerDAO.database_id,
    }


class MugDAO(
    DrinkingContainerDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Mug
    ],
):

    __tablename__ = "MugDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(DrinkingContainerDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "MugDAO",
        "inherit_condition": database_id == DrinkingContainerDAO.database_id,
    }


class DroneDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Drone
    ],
):

    __tablename__ = "DroneDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DroneDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class FoodDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Food
    ],
):

    __tablename__ = "FoodDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "FoodDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class BreadDAO(
    FoodDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Bread
    ],
):

    __tablename__ = "BreadDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FoodDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BreadDAO",
        "inherit_condition": database_id == FoodDAO.database_id,
    }


class CheezeItDAO(
    FoodDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.CheezeIt
    ],
):

    __tablename__ = "CheezeItDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FoodDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CheezeItDAO",
        "inherit_condition": database_id == FoodDAO.database_id,
    }


class GelatinBoxDAO(
    FoodDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.GelatinBox
    ],
):

    __tablename__ = "GelatinBoxDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FoodDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "GelatinBoxDAO",
        "inherit_condition": database_id == FoodDAO.database_id,
    }


class PringlesDAO(
    FoodDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Pringles
    ],
):

    __tablename__ = "PringlesDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FoodDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PringlesDAO",
        "inherit_condition": database_id == FoodDAO.database_id,
    }


class ProduceDAO(
    FoodDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Produce
    ],
):

    __tablename__ = "ProduceDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FoodDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ProduceDAO",
        "inherit_condition": database_id == FoodDAO.database_id,
    }


class AppleDAO(
    ProduceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Apple
    ],
):

    __tablename__ = "AppleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ProduceDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "AppleDAO",
        "inherit_condition": database_id == ProduceDAO.database_id,
    }


class BananaDAO(
    ProduceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Banana
    ],
):

    __tablename__ = "BananaDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ProduceDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BananaDAO",
        "inherit_condition": database_id == ProduceDAO.database_id,
    }


class LettuceDAO(
    ProduceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Lettuce
    ],
):

    __tablename__ = "LettuceDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ProduceDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "LettuceDAO",
        "inherit_condition": database_id == ProduceDAO.database_id,
    }


class OrangeDAO(
    ProduceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Orange
    ],
):

    __tablename__ = "OrangeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ProduceDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "OrangeDAO",
        "inherit_condition": database_id == ProduceDAO.database_id,
    }


class PotatoDAO(
    ProduceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Potato
    ],
):

    __tablename__ = "PotatoDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ProduceDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PotatoDAO",
        "inherit_condition": database_id == ProduceDAO.database_id,
    }


class TomatoDAO(
    ProduceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Tomato
    ],
):

    __tablename__ = "TomatoDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ProduceDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "TomatoDAO",
        "inherit_condition": database_id == ProduceDAO.database_id,
    }


class TomatoSoupDAO(
    FoodDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.TomatoSoup
    ],
):

    __tablename__ = "TomatoSoupDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FoodDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "TomatoSoupDAO",
        "inherit_condition": database_id == FoodDAO.database_id,
    }


class TunaCanDAO(
    FoodDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.TunaCan
    ],
):

    __tablename__ = "TunaCanDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FoodDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "TunaCanDAO",
        "inherit_condition": database_id == FoodDAO.database_id,
    }


class HandleDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Handle
    ],
):

    __tablename__ = "HandleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "HandleDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class HouseplantDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Houseplant
    ],
):

    __tablename__ = "HouseplantDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "HouseplantDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class LidDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Lid
    ],
):

    __tablename__ = "LidDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "LidDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class PanLidDAO(
    LidDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.PanLid
    ],
):

    __tablename__ = "PanLidDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LidDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PanLidDAO",
        "inherit_condition": database_id == LidDAO.database_id,
    }


class PotLidDAO(
    LidDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.PotLid
    ],
):

    __tablename__ = "PotLidDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(LidDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PotLidDAO",
        "inherit_condition": database_id == LidDAO.database_id,
    }


class LiquidCapDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.LiquidCap
    ],
):

    __tablename__ = "LiquidCapDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "LiquidCapDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class PenDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Pen
    ],
):

    __tablename__ = "PenDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PenDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class PencilDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Pencil
    ],
):

    __tablename__ = "PencilDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PencilDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class SaltPepperShakerDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.SaltPepperShaker
    ],
):

    __tablename__ = "SaltPepperShakerDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SaltPepperShakerDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class ShelvingUnitDAO(
    FurnitureDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.ShelvingUnit
    ],
):

    __tablename__ = "ShelvingUnitDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FurnitureDAO.database_id), primary_key=True, use_existing_column=True
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ShelvingUnitDAO",
        "inherit_condition": database_id == FurnitureDAO.database_id,
    }


class SinkDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Sink
    ],
):

    __tablename__ = "SinkDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SinkDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class SofaDAO(
    FurnitureDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Sofa
    ],
):

    __tablename__ = "SofaDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(FurnitureDAO.database_id), primary_key=True, use_existing_column=True
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SofaDAO",
        "inherit_condition": database_id == FurnitureDAO.database_id,
    }


class SprayBottleDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.SprayBottle
    ],
):

    __tablename__ = "SprayBottleDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SprayBottleDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class StatueDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Statue
    ],
):

    __tablename__ = "StatueDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "StatueDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class TableDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Table
    ],
):

    __tablename__ = "TableDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "TableDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class CoffeeTableDAO(
    TableDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.CoffeeTable
    ],
):

    __tablename__ = "CoffeeTableDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(TableDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CoffeeTableDAO",
        "inherit_condition": database_id == TableDAO.database_id,
    }


class DeskDAO(
    TableDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Desk
    ],
):

    __tablename__ = "DeskDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(TableDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DeskDAO",
        "inherit_condition": database_id == TableDAO.database_id,
    }


class DiningTableDAO(
    TableDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.DiningTable
    ],
):

    __tablename__ = "DiningTableDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(TableDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DiningTableDAO",
        "inherit_condition": database_id == TableDAO.database_id,
    }


class SideTableDAO(
    TableDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.SideTable
    ],
):

    __tablename__ = "SideTableDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(TableDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "SideTableDAO",
        "inherit_condition": database_id == TableDAO.database_id,
    }


class VaseDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Vase
    ],
):

    __tablename__ = "VaseDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "VaseDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class WallPanelDAO(
    HasBodyDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.WallPanel
    ],
):

    __tablename__ = "WallPanelDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasBodyDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "WallPanelDAO",
        "inherit_condition": database_id == HasBodyDAO.database_id,
    }


class HasDoorsDAO(
    SemanticAnnotationDAO,
    DataAccessObject[semantic_digital_twin.semantic_annotations.mixins.HasDoors],
):

    __tablename__ = "HasDoorsDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    doors: Mapped[typing.List[DoorDAO]] = relationship(
        "DoorDAO", foreign_keys="[DoorDAO.hasdoorsdao_doors_id]", post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "HasDoorsDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class CupboardDAO(
    HasDoorsDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Cupboard
    ],
):

    __tablename__ = "CupboardDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasDoorsDAO.database_id), primary_key=True, use_existing_column=True
    )

    container_id: Mapped[int] = mapped_column(
        ForeignKey("ContainerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    container: Mapped[ContainerDAO] = relationship(
        "ContainerDAO", uselist=False, foreign_keys=[container_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CupboardDAO",
        "inherit_condition": database_id == HasDoorsDAO.database_id,
    }


class HasDrawersDAO(
    SemanticAnnotationDAO,
    DataAccessObject[semantic_digital_twin.semantic_annotations.mixins.HasDrawers],
):

    __tablename__ = "HasDrawersDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    drawers: Mapped[typing.List[DrawerDAO]] = relationship(
        "DrawerDAO",
        foreign_keys="[DrawerDAO.hasdrawersdao_drawers_id]",
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "HasDrawersDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class CabinetDAO(
    HasDoorsDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Cabinet
    ],
):

    __tablename__ = "CabinetDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasDoorsDAO.database_id), primary_key=True, use_existing_column=True
    )

    container_id: Mapped[int] = mapped_column(
        ForeignKey("ContainerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    drawers: Mapped[typing.List[DrawerDAO]] = relationship(
        "DrawerDAO", foreign_keys="[DrawerDAO.cabinetdao_drawers_id]", post_update=True
    )
    container: Mapped[ContainerDAO] = relationship(
        "ContainerDAO", uselist=False, foreign_keys=[container_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "CabinetDAO",
        "inherit_condition": database_id == HasDoorsDAO.database_id,
    }


class DresserDAO(
    HasDoorsDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Dresser
    ],
):

    __tablename__ = "DresserDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasDoorsDAO.database_id), primary_key=True, use_existing_column=True
    )

    container_id: Mapped[int] = mapped_column(
        ForeignKey("ContainerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    drawers: Mapped[typing.List[DrawerDAO]] = relationship(
        "DrawerDAO", foreign_keys="[DrawerDAO.dresserdao_drawers_id]", post_update=True
    )
    container: Mapped[ContainerDAO] = relationship(
        "ContainerDAO", uselist=False, foreign_keys=[container_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "DresserDAO",
        "inherit_condition": database_id == HasDoorsDAO.database_id,
    }


class WardrobeDAO(
    HasDoorsDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Wardrobe
    ],
):

    __tablename__ = "WardrobeDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasDoorsDAO.database_id), primary_key=True, use_existing_column=True
    )

    container_id: Mapped[int] = mapped_column(
        ForeignKey("ContainerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    drawers: Mapped[typing.List[DrawerDAO]] = relationship(
        "DrawerDAO", foreign_keys="[DrawerDAO.wardrobedao_drawers_id]", post_update=True
    )
    container: Mapped[ContainerDAO] = relationship(
        "ContainerDAO", uselist=False, foreign_keys=[container_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "WardrobeDAO",
        "inherit_condition": database_id == HasDoorsDAO.database_id,
    }


class HasRegionDAO(
    SemanticAnnotationDAO,
    DataAccessObject[semantic_digital_twin.semantic_annotations.mixins.HasRegion],
):

    __tablename__ = "HasRegionDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    region_id: Mapped[int] = mapped_column(
        ForeignKey("RegionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    region: Mapped[RegionDAO] = relationship(
        "RegionDAO", uselist=False, foreign_keys=[region_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "HasRegionDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class ApertureDAO(
    HasRegionDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Aperture
    ],
):

    __tablename__ = "ApertureDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasRegionDAO.database_id), primary_key=True, use_existing_column=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ApertureDAO",
        "inherit_condition": database_id == HasRegionDAO.database_id,
    }


class HasSupportingSurfaceDAO(
    SemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.mixins.HasSupportingSurface
    ],
):

    __tablename__ = "HasSupportingSurfaceDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    supporting_surface_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("RegionDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    supporting_surface: Mapped[RegionDAO] = relationship(
        "RegionDAO",
        uselist=False,
        foreign_keys=[supporting_surface_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "HasSupportingSurfaceDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class BowlDAO(
    HasSupportingSurfaceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Bowl
    ],
):

    __tablename__ = "BowlDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasSupportingSurfaceDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "BowlDAO",
        "inherit_condition": database_id == HasSupportingSurfaceDAO.database_id,
    }


class FloorDAO(
    HasSupportingSurfaceDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Floor
    ],
):

    __tablename__ = "FloorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasSupportingSurfaceDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "FloorDAO",
        "inherit_condition": database_id == HasSupportingSurfaceDAO.database_id,
    }


class PlateDAO(
    HasSupportingSurfaceDAO,
    DataAccessObject[
        semantic_digital_twin.adapters.procthor.procthor_semantic_annotations.Plate
    ],
):

    __tablename__ = "PlateDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(HasSupportingSurfaceDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "PlateDAO",
        "inherit_condition": database_id == HasSupportingSurfaceDAO.database_id,
    }


class RoomDAO(
    SemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Room
    ],
):

    __tablename__ = "RoomDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    floor_id: Mapped[int] = mapped_column(
        ForeignKey("FloorDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    floor: Mapped[FloorDAO] = relationship(
        "FloorDAO", uselist=False, foreign_keys=[floor_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "RoomDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class RootedSemanticAnnotationDAO(
    SemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.world_entity.RootedSemanticAnnotation
    ],
):

    __tablename__ = "RootedSemanticAnnotationDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    root_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    root: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[root_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "RootedSemanticAnnotationDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class AbstractRobotDAO(
    RootedSemanticAnnotationDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.AbstractRobot],
):

    __tablename__ = "AbstractRobotDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(RootedSemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    torso_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("TorsoDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    default_collision_config_id: Mapped[int] = mapped_column(
        ForeignKey("CollisionCheckingConfigDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    torso: Mapped[TorsoDAO] = relationship(
        "TorsoDAO", uselist=False, foreign_keys=[torso_id], post_update=True
    )
    manipulators: Mapped[typing.List[ManipulatorDAO]] = relationship(
        "ManipulatorDAO",
        foreign_keys="[ManipulatorDAO.abstractrobotdao_manipulators_id]",
        post_update=True,
    )
    sensors: Mapped[typing.List[SensorDAO]] = relationship(
        "SensorDAO",
        foreign_keys="[SensorDAO.abstractrobotdao_sensors_id]",
        post_update=True,
    )
    manipulator_chains: Mapped[typing.List[KinematicChainDAO]] = relationship(
        "KinematicChainDAO",
        foreign_keys="[KinematicChainDAO.abstractrobotdao_manipulator_chains_id]",
        post_update=True,
    )
    sensor_chains: Mapped[typing.List[KinematicChainDAO]] = relationship(
        "KinematicChainDAO",
        foreign_keys="[KinematicChainDAO.abstractrobotdao_sensor_chains_id]",
        post_update=True,
    )
    default_collision_config: Mapped[CollisionCheckingConfigDAO] = relationship(
        "CollisionCheckingConfigDAO",
        uselist=False,
        foreign_keys=[default_collision_config_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "AbstractRobotDAO",
        "inherit_condition": database_id == RootedSemanticAnnotationDAO.database_id,
    }


class SemanticEnvironmentAnnotationDAO(
    RootedSemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.world_description.world_entity.SemanticEnvironmentAnnotation
    ],
):

    __tablename__ = "SemanticEnvironmentAnnotationDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(RootedSemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "SemanticEnvironmentAnnotationDAO",
        "inherit_condition": database_id == RootedSemanticAnnotationDAO.database_id,
    }


class SemanticRobotAnnotationDAO(
    RootedSemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.robots.abstract_robot.SemanticRobotAnnotation
    ],
):

    __tablename__ = "SemanticRobotAnnotationDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(RootedSemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "SemanticRobotAnnotationDAO",
        "inherit_condition": database_id == RootedSemanticAnnotationDAO.database_id,
    }


class KinematicChainDAO(
    SemanticRobotAnnotationDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.KinematicChain],
):

    __tablename__ = "KinematicChainDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticRobotAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    abstractrobotdao_manipulator_chains_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("AbstractRobotDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )
    abstractrobotdao_sensor_chains_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("AbstractRobotDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )
    tip_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    manipulator_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("ManipulatorDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    tip: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[tip_id], post_update=True
    )
    manipulator: Mapped[ManipulatorDAO] = relationship(
        "ManipulatorDAO", uselist=False, foreign_keys=[manipulator_id], post_update=True
    )
    sensors: Mapped[typing.List[SensorDAO]] = relationship(
        "SensorDAO",
        foreign_keys="[SensorDAO.kinematicchaindao_sensors_id]",
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "KinematicChainDAO",
        "inherit_condition": database_id == SemanticRobotAnnotationDAO.database_id,
    }


class ArmDAO(
    KinematicChainDAO, DataAccessObject[semantic_digital_twin.robots.abstract_robot.Arm]
):

    __tablename__ = "ArmDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(KinematicChainDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ArmDAO",
        "inherit_condition": database_id == KinematicChainDAO.database_id,
    }


class FingerDAO(
    KinematicChainDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.Finger],
):

    __tablename__ = "FingerDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(KinematicChainDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "FingerDAO",
        "inherit_condition": database_id == KinematicChainDAO.database_id,
    }


class NeckDAO(
    KinematicChainDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.Neck],
):

    __tablename__ = "NeckDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(KinematicChainDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    pitch_body_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    yaw_body_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    pitch_body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[pitch_body_id], post_update=True
    )
    yaw_body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[yaw_body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "NeckDAO",
        "inherit_condition": database_id == KinematicChainDAO.database_id,
    }


class TorsoDAO(
    KinematicChainDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.Torso],
):

    __tablename__ = "TorsoDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(KinematicChainDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "TorsoDAO",
        "inherit_condition": database_id == KinematicChainDAO.database_id,
    }


class ManipulatorDAO(
    SemanticRobotAnnotationDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.Manipulator],
):

    __tablename__ = "ManipulatorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticRobotAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    abstractrobotdao_manipulators_id: Mapped[typing.Optional[builtins.int]] = (
        mapped_column(
            ForeignKey("AbstractRobotDAO.database_id", use_alter=True),
            nullable=True,
            use_existing_column=True,
        )
    )
    tool_frame_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    front_facing_orientation_id: Mapped[int] = mapped_column(
        ForeignKey("PyCRAMQuaternionMappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    front_facing_axis_id: Mapped[int] = mapped_column(
        ForeignKey("Vector3MappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    tool_frame: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[tool_frame_id], post_update=True
    )
    front_facing_orientation: Mapped[PyCRAMQuaternionMappingDAO] = relationship(
        "PyCRAMQuaternionMappingDAO",
        uselist=False,
        foreign_keys=[front_facing_orientation_id],
        post_update=True,
    )
    front_facing_axis: Mapped[Vector3MappingDAO] = relationship(
        "Vector3MappingDAO",
        uselist=False,
        foreign_keys=[front_facing_axis_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "ManipulatorDAO",
        "inherit_condition": database_id == SemanticRobotAnnotationDAO.database_id,
    }


class ParallelGripperDAO(
    ManipulatorDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.ParallelGripper],
):

    __tablename__ = "ParallelGripperDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(ManipulatorDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    finger_id: Mapped[int] = mapped_column(
        ForeignKey("FingerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    thumb_id: Mapped[int] = mapped_column(
        ForeignKey("FingerDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    finger: Mapped[FingerDAO] = relationship(
        "FingerDAO", uselist=False, foreign_keys=[finger_id], post_update=True
    )
    thumb: Mapped[FingerDAO] = relationship(
        "FingerDAO", uselist=False, foreign_keys=[thumb_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "ParallelGripperDAO",
        "inherit_condition": database_id == ManipulatorDAO.database_id,
    }


class SensorDAO(
    SemanticRobotAnnotationDAO,
    DataAccessObject[semantic_digital_twin.robots.abstract_robot.Sensor],
):

    __tablename__ = "SensorDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticRobotAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    abstractrobotdao_sensors_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("AbstractRobotDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    kinematicchaindao_sensors_id: Mapped[typing.Optional[builtins.int]] = mapped_column(
        ForeignKey("KinematicChainDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "SensorDAO",
        "inherit_condition": database_id == SemanticRobotAnnotationDAO.database_id,
    }


class CameraDAO(
    SensorDAO, DataAccessObject[semantic_digital_twin.robots.abstract_robot.Camera]
):

    __tablename__ = "CameraDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SensorDAO.database_id), primary_key=True, use_existing_column=True
    )

    minimal_height: Mapped[builtins.float] = mapped_column(use_existing_column=True)
    maximal_height: Mapped[builtins.float] = mapped_column(use_existing_column=True)

    forward_facing_axis_id: Mapped[int] = mapped_column(
        ForeignKey("Vector3MappingDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )
    field_of_view_id: Mapped[int] = mapped_column(
        ForeignKey("FieldOfViewDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    forward_facing_axis: Mapped[Vector3MappingDAO] = relationship(
        "Vector3MappingDAO",
        uselist=False,
        foreign_keys=[forward_facing_axis_id],
        post_update=True,
    )
    field_of_view: Mapped[FieldOfViewDAO] = relationship(
        "FieldOfViewDAO",
        uselist=False,
        foreign_keys=[field_of_view_id],
        post_update=True,
    )

    __mapper_args__ = {
        "polymorphic_identity": "CameraDAO",
        "inherit_condition": database_id == SensorDAO.database_id,
    }


class WallDAO(
    SemanticAnnotationDAO,
    DataAccessObject[
        semantic_digital_twin.semantic_annotations.semantic_annotations.Wall
    ],
):

    __tablename__ = "WallDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        ForeignKey(SemanticAnnotationDAO.database_id),
        primary_key=True,
        use_existing_column=True,
    )

    body_id: Mapped[int] = mapped_column(
        ForeignKey("BodyDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    body: Mapped[BodyDAO] = relationship(
        "BodyDAO", uselist=False, foreign_keys=[body_id], post_update=True
    )

    __mapper_args__ = {
        "polymorphic_identity": "WallDAO",
        "inherit_condition": database_id == SemanticAnnotationDAO.database_id,
    }


class WorldModelModificationDAO(
    Base,
    DataAccessObject[
        semantic_digital_twin.world_description.world_modification.WorldModelModification
    ],
):

    __tablename__ = "WorldModelModificationDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    worldmodelmodificationblockdao_modifications_id: Mapped[
        typing.Optional[builtins.int]
    ] = mapped_column(
        ForeignKey("WorldModelModificationBlockDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )


class WorldModelModificationBlockDAO(
    Base,
    DataAccessObject[
        semantic_digital_twin.world_description.world_modification.WorldModelModificationBlock
    ],
):

    __tablename__ = "WorldModelModificationBlockDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    executiondatadao_added_world_modifications_id: Mapped[
        typing.Optional[builtins.int]
    ] = mapped_column(
        ForeignKey("ExecutionDataDAO.database_id", use_alter=True),
        nullable=True,
        use_existing_column=True,
    )

    modifications: Mapped[typing.List[WorldModelModificationDAO]] = relationship(
        "WorldModelModificationDAO",
        foreign_keys="[WorldModelModificationDAO.worldmodelmodificationblockdao_modifications_id]",
        post_update=True,
    )


class WorldStateMappingDAO(
    Base, DataAccessObject[semantic_digital_twin.orm.model.WorldStateMapping]
):

    __tablename__ = "WorldStateMappingDAO"

    database_id: Mapped[builtins.int] = mapped_column(
        Integer, primary_key=True, use_existing_column=True
    )

    data: Mapped[typing.List[builtins.float]] = mapped_column(
        JSON, nullable=False, use_existing_column=True
    )

    names: Mapped[typing.List[PrefixedNameDAO]] = relationship(
        "PrefixedNameDAO",
        foreign_keys="[PrefixedNameDAO.worldstatemappingdao_names_id]",
        post_update=True,
    )
